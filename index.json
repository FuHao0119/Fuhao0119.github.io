
[{"content":"","date":"18 Oct 2025","externalUrl":null,"permalink":"/","section":"FUのBlog","summary":"","title":"FUのBlog","type":"page"},{"content":"","date":"18 Oct 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"这周在学遗传算法，老师布置了一个有趣的作业：用遗传算法解决背包问题。经过几次调试，终于得到了正确的结果！\n问题描述 # 假设要去登山，背包最多能装30公斤，有6件物品可选：\n物品 重量 生存点数 睡袋 15 15 绳子 3 7 小刀 2 10 手电筒 5 5 瓶子 9 8 葡萄糖 20 17 目标：选择物品，在不超过30公斤的前提下，让生存点数最大。\n最终结果 # 经过遗传算法优化，找到了最优解：\n最优个体编码: [1, 1, 1, 0, 1, 0] 选择的物品: 睡袋、绳子、小刀、瓶子 总重量: 15 + 3 + 2 + 9 = 29公斤 生存点数: 15 + 7 + 10 + 8 = 40点 这个结果完全满足重量约束，并且获得了最大的生存点数。\n核心代码解读 # 1. 适应度计算 # private static Integer[] getFitness_(Integer[][] as, Item[] items) { Integer[] fitnesses = new Integer[as.length]; for(int j=0; j\u0026lt;as.length; j++){ Integer fitness = 0; Integer weight = 0; for(int i=0; i\u0026lt;as[j].length; i++){ if(as[j][i] == 1) { fitness += items[i].survivalPoints; weight += items[i].weight; } } if(weight \u0026gt; MAXWEIGHT) {fitnesses[j] = 0;} else {fitnesses[j] = fitness;} } return fitnesses; } 作用：计算每个个体的适应度。关键点是当重量超限时，适应度设为0，这样超重的解就不会被选中。\n2. 轮盘赌选择 # static int chooseA(Double[] sum_probabilitys, double r){ int i = 0; for(; i\u0026lt;sum_probabilitys.length; i++){ if(r \u0026lt; sum_probabilitys[i]){ return i; } } return i-1; } 作用：根据适应度比例选择父代。适应度高的个体有更大几率被选中繁殖。\n3. 单点交叉 # static void cross(Integer[] a1, Integer[] a2){ Integer[] b1 = new Integer[a1.length]; Integer[] b2 = new Integer[a2.length]; int mid = a1.length / 2; for(int i = 0; i \u0026lt; a1.length; i++){ if(i \u0026lt; mid){ b1[i] = a1[i]; b2[i] = a2[i]; } else { b1[i] = a2[i]; b2[i] = a1[i]; } } System.arraycopy(b1,0,a1,0,a1.length); System.arraycopy(b2,0,a2,0,a2.length); } 作用：在两个父代的中间位置进行基因交换，产生新的子代。\n4. 随机变异 # static void mutate(Integer[] a){ if(Math.random() \u0026lt; MUTATION_PROBABILITY){ int randomIndex = (int)(Math.random() * a.length); a[randomIndex] = a[randomIndex] == 1 ? 0 : 1; } } 作用：以很小概率（0.5%）随机改变一个基因位，保持种群多样性。\n算法流程 # 初始化：创建8个随机个体作为初始种群 评估：计算每个个体的适应度 选择：用轮盘赌方法选择优秀的父代 交叉：父代基因重组产生子代 变异：对子代进行随机变异 替换：用新的子代替换旧的个体 重复：循环100万代，记录历史最优解 参数设置 # 种群大小：8个个体 变异概率：0.5% 最大迭代：1,000,000代 交叉方式：单点交叉 遇到的问题和解决 # 1. 数组引用问题 # 最初直接修改原种群数组，导致意外修改。解决方案是：\n// 先创建副本操作 Integer[] child1 = Arrays.copyOf(As[A_index1], As[A_index1].length); // ...交叉变异操作... // 再替换回去 System.arraycopy(child1, 0, As[A_index1], 0, As[A_index1].length); 2. 重量计算错误 # 最初计算重量时忘了判断物品是否被选中：\n// 错误：weight += items[i].weight; // 正确：if (code[i] == 1) { weight += items[i].weight; } 心得体会 # 遗传算法很强大：通过模拟自然进化，确实能找到优质解 细节很重要：一个小bug就可能导致整个算法失效 参数调优需要耐心：变异率太高会破坏好解，太低会陷入局部最优 验证结果必要：找到解后要手动验证是否满足约束条件 这次实践让我真正理解了遗传算法的工作原理。从最初的bug频出，到最终找到最优解，整个过程很有成就感！\n完整代码：https://github.com/FuHao0119/CodeInLeeCode/blob/master/src/GeneticOnBag/GeneticOnBagMain.java\n算法学习之路，继续前进！\n","date":"18 Oct 2025","externalUrl":null,"permalink":"/posts/my-second-post/","section":"Posts","summary":"","title":"用遗传算法解决背包问题：一次成功的实践","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]