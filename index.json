
[{"content":"","date":"08 Nov 2025","externalUrl":null,"permalink":"/","section":"FUのBlog","summary":"","title":"FUのBlog","type":"page"},{"content":"","date":"08 Nov 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" 迷宫路径搜索算法比较与分析 # 问题描述 # 迷宫问题是一个经典的人工智能问题，通过模拟程序在迷宫中的寻路过程，可以探索和比较不同的寻路算法的优劣。在此问题中，我们选择使用BFS算法和A*算法解决迷宫问题并进行算法分析。\n迷宫定义 # 采用一个10×10的矩阵，起点坐标为(0,0)，终点坐标为(9,9)\n迷宫矩阵：\n0 1 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 1 1 0 0 0 0 1 0 0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 1 0 0 0 0：代表可通行的路径 1：代表墙壁障碍物 广度优先搜索（BFS） # 算法原理 # 广度优先搜索算法类似于树的层序遍历，基于队列这一数据结构来实现。其算法思想为：首先将起始节点存入队列，并记录为已访问。取出队首节点，并访问其未访问过的邻居结点，将邻居结点加入队列，并记录该节点为已访问。重复此步骤，直至队列为空或找到目标节点。\n算法步骤 # 对于迷宫问题，广度优先搜索算法主要步骤如下：\n初始化：将起始节点加入队列 循环搜索：当队列不为空时，执行以下操作： 访问队首节点 判断是否为出口节点，如果是则程序结束，找到了最短的出口路径 访问该节点邻居，判断邻居结点是否： 超出边界 是否为墙 是否已访问过 将符合条件的邻居节点加入队列，并标记为已访问 路径回溯：通过父节点记录重构完整路径 算法特点 # 完备性：保证找到解（如果存在） 最优性：在无权图中保证找到最短路径 盲目性：无目标方向信息，均匀扩展 A*搜索算法 # 算法原理 # A算法是一种启发式搜索算法，它综合了广度优先搜索和贪心算法的思想，以寻找最短路径为目标。A算法运用了一种评估函数值的方法来估算节点的代价，该函数值是实际移动代价和预计代价的总和。\n评价函数 # f(x) = g(x) + h(x)\ng(x)：从源点到x的实际代价值 h(x)：从x到目标点的预估代价值 启发函数：使用曼哈顿距离\nh(x) = abs(x1 - x2) + abs(y1 - y2) 算法步骤 # 初始化：将起点加入优先队列 循环搜索：当优先队列不为空时，执行以下步骤： 从队列中取出优先级最高的节点（总代价最小的结点） 如果当前节点为出口，则搜索结束 否则访问当前节点的邻居结点（满足不越出边界并且不是墙） 计算邻居结点的实际代价 = 当前节点实际代价 + 1 如果邻居结点的实际代价没有被记录或实际代价比之前更短，则： 更新实际代价 计算邻居结点的总代价 = 邻居节点实际代价 + 预估代价 将节点存入优先队列 终止条件：如果队列为空而没有找到目标节点，则表示无法到达出口 算法特点 # 启发式引导：利用目标位置信息优化搜索方向 效率较高：减少无效搜索 最优性保证：在可采纳启发函数下找到最短路径 BFS与A*算法的分析比较 # 搜索策略对比 # 特性 BFS A*算法 搜索策略 逐层遍历，盲目探索 启发式引导，方向性搜索 数据结枃 队列（FIFO） 优先队列（按代价排序） 搜索效率 较低，访问节点多 较高，访问节点少 方向性 无目标方向信息 有明确的搜索方向 空间复杂度分析 # BFS：需要存储当前层级所有待探索的结点，随着迷宫规模扩大，队列存储量线性增长，在复杂迷宫易出现内存占用过高问题 A*：优先队列需存储待探索节点及对应代价，虽同样占用空间，但因筛选出高优先级节点优先处理，队列中节点数量通常少于BFS 路径质量保证 # BFS：因逐层遍历特性，首次到达目标节点的路径即为最短路径，无需额外验证，最短路径保证绝对稳定 A*：需要设计合理的启发式函数，在可采纳性条件下保证找到最短路径 实际性能表现 # 在10×10迷宫中的测试结果：\nBFS：访问约85个节点，效率约29.4% A*：访问约35个节点，效率约71.4% 结论与建议 # 算法选择指导 # 推荐使用BFS的场景：\n迷宫规模较小 没有合适的启发式函数 环境完全未知 实现复杂度要求低 推荐使用A*的场景：\n较大的迷宫规模 知道目标位置信息 对搜索效率要求高 有合适的启发式函数可用 综合评估 # 在迷宫规模较小或没有合适的启发式函数时可以采用BFS算法，实现简单且保证最优解。而在较大的迷宫规模中，A*算法凭借其启发式搜索策略，拥有更好的搜索效率和性能表现，更适合复杂迷宫环境下的路径规划问题。\n代码实现 # bfs:\nimport numpy as np from collections import deque def bfs(maze, start, end): height, width = maze.shape visited = np.zeros((height, width), dtype=bool) parent = np.full((height, width), None, dtype=object) queue = deque([start]) visited[start[0]][start[1]] = True step = 0 while queue: x, y = queue.popleft() visiting.append((x, y)) step += 1 if (x, y) == end: print(\u0026#34;Find ending!\u0026#34;) path = [] while (x, y) != start: path.append((x, y)) x, y = parent[x][y] path.append(start) return path[::-1] # 从起点到终点 for dx, dy in direction: nx, ny = x + dx, y + dy if 0 \u0026lt;= nx \u0026lt; height and 0 \u0026lt;= ny \u0026lt; width and not visited[nx][ny] and maze[nx][ny] == 0: visited[nx][ny] = True parent[nx][ny] = (x, y) queue.append((nx, ny)) print(\u0026#34;No path found.\u0026#34;) return None # 如果找不到路径 if __name__ == \u0026#39;__main__\u0026#39;: start = (0, 0) # 用 tuple 更安全 end = (4, 4) direction = [(0, -1), (0, 1), (-1, 0), (1, 0)] # 左右上下 visiting = [] maze = np.array([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) path = bfs(maze, start, end) print(path) from queue import PriorityQueue class Maze: def __init__(self, maze): self.maze = maze def neighbors(self, current): \u0026#39;\u0026#39;\u0026#39;返回一个列表 存着这个点的四个邻居\u0026#39;\u0026#39;\u0026#39; neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = current[0] + dx, current[1] + dy if(nx \u0026gt;= 0 and ny \u0026gt;= 0 and nx \u0026lt; len(self.maze[0]) and ny \u0026lt; len(self.maze) and self.maze[nx][ny] == 0 ): neighbors.append((nx, ny)) return neighbors def cal_estimated_cost(node1, node2): \u0026#39;\u0026#39;\u0026#39;计算两个点的估计代价\u0026#39;\u0026#39;\u0026#39; return abs(node1[0] - node2[0]) + abs(node1[1] - node2[1]) def a_star_search(maze, start, goal): \u0026#39;\u0026#39;\u0026#39; :param maze: 初始迷宫 :param start: 起点坐标 :param goal: 重点坐标 :return: 两个集合（从哪来集合、实际代价集合） \u0026#39;\u0026#39;\u0026#39; frontier = PriorityQueue() # 优先队列 通过代价自动排序 frontier.put(start,0) # 将起点放入队列 起点的总代价为0就可以 因为必须最先访问 came_from = {} # 记录从哪来 cost_so_far = {} # 实际代价 came_from[start] = None # 起点就是第一个点 没有前驱 cost_so_far[start] = 0 # 第一个点实际代价是0 while not frontier.empty(): current = frontier.get() # 取出第一个元素？ if current == goal: break for next in maze.neighbors(current): new_cost = cost_so_far[current] + 1 if(next not in cost_so_far or new_cost \u0026lt; cost_so_far[next]): cost_so_far[next] = new_cost priority = new_cost + cal_estimated_cost(goal, next) # 计算出总代价 = 当前代价+预估代价 frontier.put(next,priority) # 将节点和代价放入队列 print(priority) came_from[next] = current # 记录从哪来 return came_from, cost_so_far if __name__ == \u0026#39;__main__\u0026#39;: maze = Maze([ [0,1,0,0,0,1,0,0,0,0], [0,1,0,1,0,1,0,1,1,0], [0,0,0,1,0,0,0,0,1,0], [1,1,0,1,1,1,1,0,1,0], [0,0,0,0,0,0,1,0,0,0], [0,1,1,1,1,0,1,1,1,1], [0,1,0,0,0,0,0,0,0,0], [0,1,1,1,1,1,1,1,1,0], [0,0,0,0,0,0,0,0,1,0], [1,1,1,1,1,1,1,0,0,0] ]) came_from, cost_so_far = a_star_search(maze, (0, 0), (9, 9)) print(came_from) print(cost_so_far) ","date":"08 Nov 2025","externalUrl":null,"permalink":"/posts/20251108/","section":"Posts","summary":"","title":"迷宫路径搜索算法比较与分析","type":"posts"},{"content":" 🎓 你好，我是 软件工程学生 \u0026 技术探索者\nJava Python Spring Boot MySQL Git 0 课程项目 0 编程语言 0 在校年数 0 代码行数 📚 我的学习之旅 从大一开始接触 编程，我就被计算机科学深深吸引。目前正在软件工程专业学习，热衷于将理论知识转化为实际项目。\n2023 编程入门 学习 Java 基础、数据结构和算法\n2024 Web 开发 掌握 Spring Boot、MySQL 和前端基础\n2025 项目实践 参与课程项目和开源贡献\n💻 技术技能 编程语言 Java Python JavaScript SQL 框架技术 Spring Boot MyBatis Vue.js Flask 开发工具 Git Maven MySQL Linux 📖 课程项目 🏫 学生管理系统 基于 Spring Boot 的学生信息管理平台，支持增删改查和成绩统计\nSpring Boot MySQL Thymeleaf 🛒 简易电商系统 课程设计的在线购物平台，实现用户注册、商品浏览和购物车功能\nJava Servlet JSP MySQL 📊 数据可视化工具 使用 Python 和 Flask 开发的数据分析平台，支持图表生成\nPython Flask ECharts 🎯 学习目标 🚀 技术深度 深入理解分布式系统和微服务架构\n🌐 全栈能力 掌握前后端分离开发模式\n🤝 团队协作 参与开源项目，提升协作能力\n💼 实习经历 寻找技术实习，积累实战经验\n📞 交流学习 对技术充满热情？欢迎一起交流学习心得和项目经验！\n📧 发送邮件 🐙 GitHub ","date":"19 Oct 2025","externalUrl":null,"permalink":"/about/","section":"FUのBlog","summary":"","title":"关于我","type":"page"},{"content":"这周在学遗传算法，老师布置了一个有趣的作业：用遗传算法解决背包问题。经过几次调试，终于得到了正确的结果！\n问题描述 # 假设要去登山，背包最多能装30公斤，有6件物品可选：\n物品 重量 生存点数 睡袋 15 15 绳子 3 7 小刀 2 10 手电筒 5 5 瓶子 9 8 葡萄糖 20 17 目标：选择物品，在不超过30公斤的前提下，让生存点数最大。\n最终结果 # 经过遗传算法优化，找到了最优解：\n最优个体编码: [1, 1, 1, 0, 1, 0] 选择的物品: 睡袋、绳子、小刀、瓶子 总重量: 15 + 3 + 2 + 9 = 29公斤 生存点数: 15 + 7 + 10 + 8 = 40点 这个结果完全满足重量约束，并且获得了最大的生存点数。\n核心代码解读 # 1. 适应度计算 # private static Integer[] getFitness_(Integer[][] as, Item[] items) { Integer[] fitnesses = new Integer[as.length]; for(int j=0; j\u0026lt;as.length; j++){ Integer fitness = 0; Integer weight = 0; for(int i=0; i\u0026lt;as[j].length; i++){ if(as[j][i] == 1) { fitness += items[i].survivalPoints; weight += items[i].weight; } } if(weight \u0026gt; MAXWEIGHT) {fitnesses[j] = 0;} else {fitnesses[j] = fitness;} } return fitnesses; } 作用：计算每个个体的适应度。关键点是当重量超限时，适应度设为0，这样超重的解就不会被选中。\n2. 轮盘赌选择 # static int chooseA(Double[] sum_probabilitys, double r){ int i = 0; for(; i\u0026lt;sum_probabilitys.length; i++){ if(r \u0026lt; sum_probabilitys[i]){ return i; } } return i-1; } 作用：根据适应度比例选择父代。适应度高的个体有更大几率被选中繁殖。\n3. 单点交叉 # static void cross(Integer[] a1, Integer[] a2){ Integer[] b1 = new Integer[a1.length]; Integer[] b2 = new Integer[a2.length]; int mid = a1.length / 2; for(int i = 0; i \u0026lt; a1.length; i++){ if(i \u0026lt; mid){ b1[i] = a1[i]; b2[i] = a2[i]; } else { b1[i] = a2[i]; b2[i] = a1[i]; } } System.arraycopy(b1,0,a1,0,a1.length); System.arraycopy(b2,0,a2,0,a2.length); } 作用：在两个父代的中间位置进行基因交换，产生新的子代。\n4. 随机变异 # static void mutate(Integer[] a){ if(Math.random() \u0026lt; MUTATION_PROBABILITY){ int randomIndex = (int)(Math.random() * a.length); a[randomIndex] = a[randomIndex] == 1 ? 0 : 1; } } 作用：以很小概率（0.5%）随机改变一个基因位，保持种群多样性。\n算法流程 # 初始化：创建8个随机个体作为初始种群 评估：计算每个个体的适应度 选择：用轮盘赌方法选择优秀的父代 交叉：父代基因重组产生子代 变异：对子代进行随机变异 替换：用新的子代替换旧的个体 重复：循环100万代，记录历史最优解 参数设置 # 种群大小：8个个体 变异概率：0.5% 最大迭代：1,000,000代 交叉方式：单点交叉 遇到的问题和解决 # 1. 数组引用问题 # 最初直接修改原种群数组，导致意外修改。解决方案是：\n// 先创建副本操作 Integer[] child1 = Arrays.copyOf(As[A_index1], As[A_index1].length); // ...交叉变异操作... // 再替换回去 System.arraycopy(child1, 0, As[A_index1], 0, As[A_index1].length); 2. 重量计算错误 # 最初计算重量时忘了判断物品是否被选中：\n// 错误：weight += items[i].weight; // 正确：if (code[i] == 1) { weight += items[i].weight; } 心得体会 # 遗传算法很强大：通过模拟自然进化，确实能找到优质解 细节很重要：一个小bug就可能导致整个算法失效 参数调优需要耐心：变异率太高会破坏好解，太低会陷入局部最优 验证结果必要：找到解后要手动验证是否满足约束条件 这次实践让我真正理解了遗传算法的工作原理。从最初的bug频出，到最终找到最优解，整个过程很有成就感！\n完整代码：https://github.com/FuHao0119/CodeInLeeCode/blob/master/src/GeneticOnBag/GeneticOnBagMain.java\n算法学习之路，继续前进！\n","date":"18 Oct 2025","externalUrl":null,"permalink":"/posts/20251018/","section":"Posts","summary":"","title":"用遗传算法解决背包问题：一次成功的实践","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]